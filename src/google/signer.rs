use anyhow::anyhow;
use anyhow::Result;
use http::header;

use log::debug;

use super::credential::CredentialLoader;
use super::credential::Token;
use crate::request::SignableRequest;

/// Builder for Signer.
#[derive(Default)]
pub struct Builder {
    scope: Option<String>,
    service_account: Option<String>,

    credential_path: Option<String>,
    credential_content: Option<String>,

    allow_anonymous: bool,
    disable_load_from_env: bool,
    disable_load_from_well_known_location: bool,
    disable_load_from_vm_metadata: bool,
}

impl Builder {
    /// Specify scope for Signer.
    ///
    /// For example, valid scopes for google cloud services should be
    ///
    /// - read-only: `https://www.googleapis.com/auth/devstorage.read_only`
    /// - read-write: `https://www.googleapis.com/auth/devstorage.read_write`
    /// - full-control: `https://www.googleapis.com/auth/devstorage.full_control`
    ///
    /// Reference: [Cloud Storage authentication](https://cloud.google.com/storage/docs/authentication)
    pub fn scope(&mut self, scope: &str) -> &mut Self {
        self.scope = Some(scope.to_string());
        self
    }

    /// Specify service account for Signer.
    ///
    /// If not set, use `default` instead.
    pub fn service_account(&mut self, service_account: &str) -> &mut Self {
        self.service_account = Some(service_account.to_string());
        self
    }

    /// Load credential from path.
    ///
    /// The credential should be generated by Google Cloud Platform.
    ///
    /// # Notes
    ///
    /// We will load from default credential by default, `credential_path`
    /// only used to for user customed credential path.
    ///
    /// Read more in [Authenticating as a service account](https://cloud.google.com/docs/authentication/production)
    pub fn credential_path(&mut self, path: &str) -> &mut Self {
        self.credential_path = Some(path.to_string());
        self
    }

    /// Load credential from base64 content.
    ///
    /// The credential should be generated by Google Cloud Platform.
    ///
    /// # Notes
    ///
    /// We will load from default credential by default, `credential_content`
    /// only used to for user customed credential content.
    ///
    /// Read more in [Authenticating as a service account](https://cloud.google.com/docs/authentication/production)
    pub fn credential_content(&mut self, credential: &str) -> &mut Self {
        self.credential_content = Some(credential.to_string());
        self
    }

    /// Use exising information to build a new signer.
    ///
    ///
    /// The builder should not be used anymore.
    pub fn build(&mut self) -> Result<Signer> {
        let scope = match &self.scope {
            Some(v) => v.clone(),
            None => return Err(anyhow!("google signer requires scope, but not set")),
        };

        let mut cred_loader = if let Some(path) = &self.credential_path {
            CredentialLoader::from_path(path)?
        } else if let Some(content) = &self.credential_content {
            CredentialLoader::from_base64(content)?
        } else {
            CredentialLoader::default()
        };
        cred_loader = cred_loader.with_scope(&scope);

        if self.disable_load_from_env {
            cred_loader = cred_loader.with_disable_env();
        }
        if self.disable_load_from_well_known_location {
            cred_loader = cred_loader.with_disable_well_known_location();
        }
        if self.disable_load_from_vm_metadata {
            cred_loader = cred_loader.with_disable_vm_metadata();
        }
        if self.allow_anonymous {
            cred_loader = cred_loader.with_allow_anonymous();
        }
        if let Some(acc) = &self.service_account {
            cred_loader = cred_loader.with_service_account(acc);
        }

        Ok(Signer {
            credential_loader: cred_loader,
            allow_anonymous: self.allow_anonymous,
        })
    }
}

/// Singer that implement Google OAuth2 Authentication.
///
/// ## Reference
///
/// -  [Authenticating as a service account](https://cloud.google.com/docs/authentication/production)
pub struct Signer {
    credential_loader: CredentialLoader,

    /// Allow anonymous request if credential is not loaded.
    allow_anonymous: bool,
}

impl Signer {
    /// Create a builder of Signer.
    pub fn builder() -> Builder {
        Builder::default()
    }

    /// Load credential via credential load chain specified while building.
    ///
    /// # Note
    ///
    /// This function should never be exported to avoid credential leaking by
    /// mistake.
    fn token(&self) -> Option<Token> {
        self.credential_loader.load()
    }

    /// Signing request.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use anyhow::Result;
    /// use reqsign::GoogleSigner;
    /// use reqwest::Client;
    /// use reqwest::Request;
    /// use reqwest::Url;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<()> {
    ///     // Signer will load region and credentials from environment by default.
    ///     let signer = GoogleSigner::builder()
    ///         .scope("https://www.googleapis.com/auth/devstorage.read_only")
    ///         .build()?;
    ///
    ///     // Construct request
    ///     let url = Url::parse("https://storage.googleapis.com/storage/v1/b/test")?;
    ///     let mut req = reqwest::Request::new(http::Method::GET, url);
    ///
    ///     // Signing request with Signer
    ///     signer.sign(&mut req)?;
    ///
    ///     // Sending already signed request.
    ///     let resp = Client::new().execute(req).await?;
    ///     println!("resp got status: {}", resp.status());
    ///     Ok(())
    /// }
    /// ```
    ///
    /// # TODO
    ///
    /// we can also send API via signed JWT: [Addendum: Service account authorization without OAuth](https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth)
    pub fn sign(&self, req: &mut impl SignableRequest) -> Result<()> {
        if let Some(token) = self.token() {
            req.insert_header(header::AUTHORIZATION, {
                let mut value: http::HeaderValue =
                    format!("Bearer {}", token.access_token()).parse()?;
                value.set_sensitive(true);

                value
            })?;

            return Ok(());
        }

        if self.allow_anonymous {
            debug!("token not found and anonymous is allowed, skipping signing.");
            return Ok(());
        }

        Err(anyhow!("token not found"))
    }
}
